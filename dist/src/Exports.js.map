{"version":3,"file":"Exports.js","sourceRoot":"","sources":["../../src/Exports.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA,4BAA0B;AAE1B,iDAAkD;AAElD,wEAA6G;AAC7G,sEAAqH;AAErH,4CAAwD;AAExD,SAAgB,aAAa,CAAyC,GAAM;IACxE,IAAM,sBAAsB,GAAG,sCAAyB,CAAC,GAAG,CAAC,CAAC;IAC9D,IAAM,SAAS,GAAG,4BAAgB,CAAC,GAAG,CAAC,CAAC;IACxC,IAAG,CAAC,sBAAsB;QACtB,MAAM,IAAI,KAAK,CAAC,wCAAwC,GAAG,SAAS,GAAG,uSAAuS,CAAC,CAAC;IAEpX,IAAI,eAAe;QAAiB,2BAAG;QACnC;YAAY,eAAe;iBAAf,UAAe,EAAf,qBAAe,EAAf,IAAe;gBAAf,0BAAe;;YAA3B,iBAaC;YAZG,IAAM,SAAS,GAAI,aAAW,CAAC,iBAA8B,CAAC;YAE9D,IAAM,kBAAkB,GAAG,iDAAqC,CAAC,GAAG,CAAC,CAAC;YACtE,IAAM,eAAe,GAAG,kBAAkB,CAAC,mBAAmB,EAAE,CAAC;YAEjE,IAAM,iBAAiB,GAAG,EAAE,CAAC;YAC7B,KAAiB,UAAe,EAAf,mCAAe,EAAf,6BAAe,EAAf,IAAe,EAAE;gBAA9B,IAAI,KAAK,wBAAA;gBACT,IAAM,IAAI,GAAG,kBAAkB,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;gBACpD,iBAAiB,CAAC,KAAK,CAAC,GAAG,SAAS,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;aAC9D;YAED,2BAAS,iBAAiB,UAAE;;QAChC,CAAC;QACL,cAAC;IAAD,CAAC,AAfqB,CAAc,GAAG,EAetC,CAAC;IAEF,kCAAqB,CAAC,GAAG,CAAC,CAAC;IAE3B,OAAO,eAAe,CAAC;AAC3B,CAAC;AA1BD,sCA0BC;AAEU,QAAA,UAAU,GAA6B;IAC9C,OAAO,YAAC,GAAwB,EAAE,SAAoB;QAClD,IAAG,CAAC,SAAS;YACT,MAAM,IAAI,KAAK,CAAC,kEAAkE,CAAC,CAAC;QAExF,IAAG,CAAC,CAAC,SAAS,YAAY,mBAAS,CAAC;YAChC,MAAM,IAAI,KAAK,CAAC,qDAAqD,CAAC,CAAC;QAE1E,GAAW,CAAC,iBAAiB,GAAG,SAAS,CAAC;IAC/C,CAAC;CACJ,CAAA","sourcesContent":["import \"reflect-metadata\";\n\nimport { Container } from '@fluffy-spoon/inverse';\n\nimport { addInjectableMetadata, getParameterTypesMetadata } from '@fluffy-spoon/inverse/dist/src/Decorators';\nimport { getOrCreateArgumentsMetadataForTarget, extractClassName,  } from '@fluffy-spoon/inverse/dist/src/Utilities';\n\nimport Vue, { PluginObject, VueConstructor } from 'vue';\n\nexport function VueInjectable<T extends { new(...args: any[]): any }>(cls: T): T {\n    const parameterTypesMetadata = getParameterTypesMetadata(cls);\n    const className = extractClassName(cls);\n    if(!parameterTypesMetadata)\n        throw new Error('Could not find metadata for the class ' + className + '.\\nPotential causes:\\n-> The @VueInjectable decorator was defined before other decorators that alter class metadata.\\n-> The class extends a mixin class. Mixins are not currently supported.\\n-> You do not have any arguments to inject in the constructor that have been decorated with @Inject.\\n');\n\n    var injectableClass = class extends cls {\n        constructor(..._args: any[]) {\n            const container = (Vue as any).$inverseContainer as Container;\n\n            const argumentDictionary = getOrCreateArgumentsMetadataForTarget(cls);\n            const argumentIndexes = argumentDictionary.getParameterIndexes();\n \n            const argumentsToInject = [];\n            for(let index of argumentIndexes) {\n                const type = argumentDictionary.getParameter(index);\n                argumentsToInject[index] = container.resolveInstance(type);\n            }\n\n            super(...argumentsToInject);\n        }\n    };\n    \n    addInjectableMetadata(cls);\n\n    return injectableClass;\n}\n\nexport var VueInverse = <PluginObject<Container>> {\n    install(Vue: VueConstructor<Vue>, container: Container) {\n        if(!container)\n            throw new Error('A container must be supplied when setting up the Inverse plugin.');\n\n        if(!(container instanceof Container))\n            throw new Error('The provided container is not a Container instance.');\n\n        (Vue as any).$inverseContainer = container;\n    }\n}"]}