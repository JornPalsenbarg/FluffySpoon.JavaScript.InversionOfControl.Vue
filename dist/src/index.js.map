{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA,4BAA0B;AAI1B,wEAA6G;AAC7G,sEAAqH;AAErH,4CAAwD;AAExD,SAAgB,aAAa,CAAyC,GAAM;IACxE,IAAM,sBAAsB,GAAG,sCAAyB,CAAC,GAAG,CAAC,CAAC;IAC9D,IAAG,CAAC,sBAAsB;QACtB,MAAM,IAAI,KAAK,CAAC,4GAA4G,GAAG,4BAAgB,CAAC,GAAG,CAAC,GAAG,sFAAsF,CAAC,CAAC;IAEnP,IAAI,eAAe;QAAiB,2BAAG;QACnC;YAAY,eAAe;iBAAf,UAAe,EAAf,qBAAe,EAAf,IAAe;gBAAf,0BAAe;;YAA3B,iBAaC;YAZG,IAAM,SAAS,GAAI,aAAW,CAAC,iBAA8B,CAAC;YAE9D,IAAM,kBAAkB,GAAG,iDAAqC,CAAC,GAAG,CAAC,CAAC;YACtE,IAAM,eAAe,GAAG,kBAAkB,CAAC,mBAAmB,EAAE,CAAC;YAEjE,IAAM,iBAAiB,GAAG,EAAE,CAAC;YAC7B,KAAiB,UAAe,EAAf,mCAAe,EAAf,6BAAe,EAAf,IAAe,EAAE;gBAA9B,IAAI,KAAK,wBAAA;gBACT,IAAM,IAAI,GAAG,kBAAkB,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;gBACpD,iBAAiB,CAAC,KAAK,CAAC,GAAG,SAAS,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;aAC9D;YAED,2BAAS,iBAAiB,UAAE;;QAChC,CAAC;QACL,cAAC;IAAD,CAAC,AAfqB,CAAc,GAAG,EAetC,CAAC;IAEF,kCAAqB,CAAC,GAAG,CAAC,CAAC;IAE3B,OAAO,eAAe,CAAC;AAC3B,CAAC;AAzBD,sCAyBC;AAMD,kBAAuC;IACnC,OAAO,YAAC,GAAwB,EAAE,OAAiB;QAC/C,IAAG,CAAC,OAAO,IAAI,CAAC,OAAO,CAAC,SAAS;YAC7B,MAAM,IAAI,KAAK,CAAC,sFAAsF,CAAC,CAAC;QAE3G,GAAW,CAAC,iBAAiB,GAAG,OAAO,CAAC,SAAS,CAAC;IACvD,CAAC;CACJ,CAAA","sourcesContent":["import \"reflect-metadata\";\r\n\r\nimport { Container } from '@fluffy-spoon/inverse';\r\n\r\nimport { addInjectableMetadata, getParameterTypesMetadata } from '@fluffy-spoon/inverse/dist/src/Decorators';\r\nimport { getOrCreateArgumentsMetadataForTarget, extractClassName,  } from '@fluffy-spoon/inverse/dist/src/Utilities';\r\n\r\nimport Vue, { PluginObject, VueConstructor } from 'vue';\r\n\r\nexport function VueInjectable<T extends { new(...args: any[]): any }>(cls: T) {\r\n    const parameterTypesMetadata = getParameterTypesMetadata(cls);\r\n    if(!parameterTypesMetadata)\r\n        throw new Error('A @VueInjectable decorator must be defined after other decorators that alter class metadata for the class ' + extractClassName(cls) + '. If in doubt, re-order the decorators so that the @VueInjectable decorator is last.');\r\n\r\n    var injectableClass = class extends cls {\r\n        constructor(..._args: any[]) {\r\n            const container = (Vue as any).$inverseContainer as Container;\r\n\r\n            const argumentDictionary = getOrCreateArgumentsMetadataForTarget(cls);\r\n            const argumentIndexes = argumentDictionary.getParameterIndexes();\r\n \r\n            const argumentsToInject = [];\r\n            for(let index of argumentIndexes) {\r\n                const type = argumentDictionary.getParameter(index);\r\n                argumentsToInject[index] = container.resolveInstance(type);\r\n            }\r\n\r\n            super(...argumentsToInject);\r\n        }\r\n    };\r\n    \r\n    addInjectableMetadata(cls);\r\n\r\n    return injectableClass;\r\n}\r\n\r\ntype Options = {\r\n    container: Container\r\n}\r\n\r\nexport default <PluginObject<Options>> {\r\n    install(Vue: VueConstructor<Vue>, options?: Options) {\r\n        if(!options || !options.container)\r\n            throw new Error('A container must be supplied through the options when setting up the Inverse plugin.');\r\n\r\n        (Vue as any).$inverseContainer = options.container;\r\n    }\r\n}"]}